# 散列表（中）如何构造可用散列表

## 一、问题引出

* 问题1：散列表的查询效率和散列函数的设计，装载因子，散列冲突有关系。其中装载因子会增大散列冲突发生的概率。
* 问题2：极端情况恶意的攻击者会精心构造数据，使得数据散列后都在一个槽位上，进而查询效率大大下降。这也是**散列表碰撞攻击**的基本原理。

**因此如何设计一个避免散列冲突和抵抗散列碰撞攻击的散列表呢？**



## 二、解决方案

### 1、如何设计散列函数

散列函数直接决定了散列冲突发生的概率大小，也就直接决定了散列表的性能。

* 首先，散列函数不能太复杂。太复杂的散列函数会消耗太多的计算时间。
* 其次，散列值的生成尽可能的随机均匀分布。这样才能避免或者最小化散列冲突。
* 其它实际因素，例如关键字的长度、特点、分布，还有散列表的大小等。

---

几个常见的例子：

（1）由于手机号前几位很可能重复，但是后几位比较随机，所以可以将手机号的后四位作为散列值。这种散列函		  数的设计方法，叫做**“数据分析法”**。

（2）实现Word拼写检查功能。

​		  将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单		  词 nice，我们转化出来的散列值就是下面这样：

```java
hash("nice")=(("n" - "a") * 26*26*26 + ("i" - "a")*26*26 + ("c" - "a")*26+ ("e"-"a")) / 78978
```

---

* 其它散列函数设计的方法：直接寻址法、平方取中法、折叠法、随机数法等。



### 2、装载因子过大了怎么办

* 对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。
* 当装载因子过大时，可以进行动态扩容。但是散列表的扩容要复杂的多，因为散列表的大小变了，数据的存储位置也变了。需要通过散列函数重新计算存储位置。

<img src="https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg" alt="img" style="zoom:50%;" />

* 动态扩容散列表插入一个数据最好复杂度O(1)，最差O(n)，摊还分析后就是O(1)。如果对空间消耗比较敏感，可以在装载因子过小的时候再进行缩容。

### 3、如何避免低效扩容

* 当装载因子到达阈值的时候，插入元素前需要先扩容，而扩容要对老数据重新进行哈希计算。此次的插入效率就会变得让人难以忍受。为了避免这种情况，可以通过以下方式
* 到达阈值时，先申请新的空间。之后将扩容操作穿插在插入操作过程中，每当插入新数据时，将新数据插入到新散列表中，并且在老散列表中拿出一个数据放入新散列表中。每次插入新数据都如此反复，直到老数据全部都被搬移到新的散列表中。

<img src="https://static001.geekbang.org/resource/image/6d/cb/6d6736f986ec4b75dabc5472965fb9cb.jpg" alt="img" style="zoom:50%;" />

### 4、如何选择冲突解决方法

#### （1）开放寻址法

* **优点**
  * 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。
  * 这种方法实现的散列表，序列化起来比较简单

* **缺点**
  * 删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据
  * 所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高
* **总结**
  * 当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因

#### （2）链表法

* **优点**

  * 链表法对内存的利用率比开放寻址法要高
  * 对大装载因子的容忍度更高

* **缺点**

  * 链表因为要存储指针，可能会让内存的消耗翻倍
  * 对 CPU 缓存是不友好

  ---

  链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击

  ---

* **总结**

  * 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。



## 三、工业散列表举例分析

### 1.Java中的HashMap

#### (1) 初始大小

* 默认是16，可设置。事先预知数据量大概多大，则可以设置默认大小，减少动态扩容的次数，提高使用效率。

#### (2) 装载因子和动态扩容

* 最大装载因子是0.75，当超过该装载因子则会启动扩容。扩容为原来的两倍大小。

#### (3) 散列冲突解决办法

* HashMap底层采用链表法解决散列冲突，但是仍然避免不了“拉链过长”的情况。拉链过长会严重影响散列表的性能。
* 因此Java1.8做了优化处理，引入了红黑树。当链表长度过长，默认超过8的时候，则转换为红黑树。当红黑树节点少于8个的时候，又转换为链表。**因此数据量较小的时候，红黑树要维持平衡，比起链表性能优势并不明显。**

#### (4)散列函数

* 散列函数追求的是简单高效均匀分布。

```java
int hash(Object key) {
    int h = key.hashCode();
    return (h ^ (h >>> 16)) & (capicity -1); //capicity表示散列表的大小
}
```

* 其中hashCode()返回的是Java对象的hashCode。比如String类型对象的hashCode()：

```java

public int hashCode() {
  int var1 = this.hash;
  if(var1 == 0 && this.value.length > 0) {
    char[] var2 = this.value;
    for(int var3 = 0; var3 < this.value.length; ++var3) {
      var1 = 31 * var1 + var2[var3];
    }
    this.hash = var1;
  }
  return var1;
}
```



## 四、如何设计一个工业级的散列表

#### 1.何为一个工业级的散列表？工业级的散列表应该具有哪些特性？

* 支持快速的查询、插入、删除操作；

* 内存占用合理，不能浪费过多的内存空间；

* 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。

  

#### 2.如何实现这样一个散列表呢？

* 设计一个合适的散列函数；
* 定义装载因子阈值，并且设计动态扩容策略；
* 选择合适的散列冲突解决方法。