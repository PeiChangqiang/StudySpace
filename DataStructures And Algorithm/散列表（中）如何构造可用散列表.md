# 散列表（中）如何构造可用散列表

## 一、问题引出

* 问题1：散列表的查询效率和散列函数的设计，装载因子，散列冲突有关系。其中装载因子会增大散列冲突发生的概率。
* 问题2：极端情况恶意的攻击者会精心构造数据，使得数据散列后都在一个槽位上，进而查询效率大大下降。这也是**散列表碰撞攻击**的基本原理。

**因此如何设计一个避免散列冲突和抵抗散列碰撞攻击的散列表呢？**



## 二、解决方案

### 1、如何设计散列函数

散列函数直接决定了散列冲突发生的概率大小，也就直接决定了散列表的性能。

* 首先，散列函数不能太复杂。太复杂的散列函数会消耗太多的计算时间。
* 其次，散列值的生成尽可能的随机均匀分布。这样才能避免或者最小化散列冲突。
* 其它实际因素，例如关键字的长度、特点、分布，还有散列表的大小等。

---

几个常见的例子：

（1）由于手机号前几位很可能重复，但是后几位比较随机，所以可以将手机号的后四位作为散列值。这种散列函		  数的设计方法，叫做**“数据分析法”**。

（2）实现Word拼写检查功能。

​		  将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单		  词 nice，我们转化出来的散列值就是下面这样：

```java
hash("nice")=(("n" - "a") * 26*26*26 + ("i" - "a")*26*26 + ("c" - "a")*26+ ("e"-"a")) / 78978
```

---

* 其它散列函数设计的方法：直接寻址法、平方取中法、折叠法、随机数法等。



### 2、装载因子过大了怎么办

* 对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。
* 当装载因子过大时，可以进行动态扩容。