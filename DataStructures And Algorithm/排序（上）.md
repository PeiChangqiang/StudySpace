# 排序（上）：为什么插入排序比冒泡排序更受欢迎

### 一、经典常用排序算法分类

* 按照时间复杂度分类

<img src="https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg" alt="img" style="zoom: 60%;" />



### 二、如何分析一个排序算法

#### (1)排序算法的执行效率

* 最好最坏情况，平均情况时间复杂度

  对于要排序的数据，有的接近有序，有的完全无序，**有序度不同的数据，不同的排序算法性能是不一样的**。

* 时间复杂度的系数、常数、低阶

  在数据规模不断增大我们分析时间复杂度的时候，常常忽略系数常数低阶。但**在对同一阶（指的是数据规模大小差不多）时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来**。

* 比较次数和交换（或移动）次数

  基于比较的排序算法会涉及两种操作。**第一种是比较大小，第二种是交换位置或者移动**。所以比较次数和交换次数也应该考虑进去。

#### (2)排序算法的内存消耗

* 内存消耗可以用空间复杂度来衡量。这一节的三种排序算法空间复杂度都是O(1)。空间复杂度为O(1)的排序算法，我们特别称之为<font color='red'>“**原地排序算法**”</font>。

#### (3)排序算法的稳定性

* 这个概念很重要，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。如果变了，那就是不稳定。
* 这种稳定性在需要**多列排序**时很有作用。例如数据库中按照订单的金额和下单时间排序。我们先可以按照下单时间排序，之后再按照订单金额排序，这时候原先金额相等的两个对象，位置会保持不变。

<img src="https://static001.geekbang.org/resource/image/13/59/1381c1f3f7819ae61ab17455ed7f0b59.jpg" alt="img" style="zoom:60%;" />



### 三、冒泡排序（Bubble Sort）

#### 冒泡排序的思路以及算法说明

* 冒泡排序只比较相邻两个元素的关系，满足条件就互换位置。这里的原始数据假设是：4,5,6,3,2,1。第一次冒泡过程如图所示。

<img src="https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg" alt="img" style="zoom:50%;" />

* 按照这样的思路，每次冒泡的结果如下：

<img src="https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg" alt="img" style="zoom:50%;" />

* 6次冒泡后排序结束，这里可以优化的地方在于，当某次冒泡已经没有数据可以交换时，意味着已经排好序，不用再继续冒泡。例如下图所示：

<img src="https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg" alt="img" style="zoom:50%;" />

* 冒泡排序的核心代码

```java
	/**
	 * 冒泡排序，复杂度O(n^2)
	 * @param array
	 */
	public static void bubbleSort(int[] array) {
		if(array == null)
			return;
		for(int i = 0; i < array.length; i++) {
			boolean flag = true;//标志位判断是否有交换的数据
			//这里减去i是因为每次循环到了i次意味有i个数已经排好序，无需再进行比较。
			for(int j = 0; j < array.length - i - 1; j++) {
                //每次循环都比较相邻两个数，如果第一个比第二个大那就调换位置
				if(array[j] > array[j+1]) {
					int temp = array[j];
					array[j] = array[j+1];
					array[j+1]=temp;
					flag = false;
				}
			}
			if(flag)//flag没有变成false说明没有数据交换了,无需再冒泡
				break;
		}
	}
```

#### 冒泡排序算法分析

按照前面分析排序算法的思路，需要考虑三个问题。

##### (1)冒泡排序是原地排序算法吗？

* 由于额外的空间只有交换位置时创建一个临时变量，因此空间复杂度是O(1)，是原地排序。

##### (2)冒泡排序是稳定的排序算法吗？

* 当相邻两个元素比较时相等，我们不做交换，那么原始顺序就不会改变。所以冒泡是稳定的排序算法。

##### (3)冒泡排序的时间复杂度是多少？

* 最好情况，一开始数据就是有序的，那么只会进行一次冒泡，**最好情况时间复杂度是O(n)**。

* 最坏情况，一开始数据是倒序的，那么就需要进行n次冒泡，**最坏情况时间复杂度是O(n^2)**。

* 平均情况，n个数据有n!种排列情况。每种情况的排序复杂度不一样，再结合概率论分析就会很复杂。这里用另一种思路，通过<font color='red'>“**有序度**”和“**逆序度**”</font>的概念分析。


---

  <font color='red'>**有序度**</font>是数组中**具有有序关系的元素对的个数**。即a[i] <= a[j], 其中i < j。那么a[i]和a[j]就是有序元素对。

  <img src="https://static001.geekbang.org/resource/image/a1/20/a1ef4cc1999d6bd0af08d8417ee55220.jpg" alt="img" style="zoom: 60%;" />

对于完全倒序排列的数组例如[6,5,4,3,2,1]，那么它的有序度是0。完全有序的数组[1,2,3,4,5,6]，它的有序度是<font color='red'>**n*(n-1)/2**</font>，即15。这种完全有序的有序度叫做**满有序度**。

逆序度和有序度相反。即a[i] > a[j], 其中i < j。并且<font color='red'>**逆序度 = 满有序度 - 有序度**</font>。**排序过程其实就是增加有序度，减少逆序度的过程**，当到达满有序度时，则排序完成。

---

冒泡排序有两种原子操作，**比较大小**和**交换位置**。每交换一次位置，有序度就增加1。逆序度决定了会交换多少次。那么平均交换次数就是最好情况有序度（即0）和最坏情况有序度n*(n-1)/2的平均值：n*(n-1)/4。我们把这个平均值作为一般情况下的交换次数。而比较大下的执行次数肯定是大于交换次数的，而复杂度的上限是O(n^2),所以平均情况的时间复杂度就是O(n^2)。

这种推导分析并不严格，但是实际情况很有用，很有参考价值。



### 四、插入排序（Insertion Sort）

#### 插入排序的思路以及算法说明

* 对于有序的数组，往里面添加新的数据，只要找到新数据应该插入的位置，移动数据位置再插入即可。

<img src="https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg" alt="img" style="zoom:60%;" />

* 这是一种动态排序，这种方式可以保证数组中的元素一直有序。这就是插入排序算法的灵感来源。

* 我们将数组区分为两个区间：**已排序区间**和**未排序区间**。初始已排序区间只有数组第一个元素。插入排序算法的核心思想是**从未排序区间依次取出一个数放到已排序区间合适的位置**。直到未排序区间的元素为空。

<img src="https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg" alt="img" style="zoom:60%;" />

* 插入排序也有两种操作，**比较大小**和**移动元素位置**。但是对于查找插入点方法（从头到尾，从尾到头）元素的比较次数是有区别的。但对于给定的初始序列，移动操作的次数总是固定的，等于逆序度。（因为每移动一次有序度增加1，逆序度就减1，逆序度为0时就排好序了）
* 

### 五、选择排序（Selection Sort）

