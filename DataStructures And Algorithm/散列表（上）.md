# 散列表（上）

## 一、 散列思想

* 散列表用的是数组支持按照下标随机访问的特性，是一种扩展的数组。把**<font color='red'>键</font>**通过**<font color='red'>散列函数</font>**计算得到的**<font color='red'>散列值</font>**（数组下标）这种思想叫做散列思想。

<img src="https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg" alt="img" style="zoom: 50%;" />

* 按照元素的键值查询信息时，通过散列函数计算出数组的下标，再根据这个下标就可以取出这个元素的数据信息。

## 二、散列函数

#### 散列函数设计的基本要求

1. 散列函数计算得到的散列值是一个非负整数。
2. 如果key1 == key2，那么hash(key1) == hash(key2)。
3. 如果key1 != key2，那么hash(key1) != hash(key2)。

---

因为计算得到的是数组下标，因此需要结果非负整数。

当两个键值相等时，我们认为这是同一个数组下标存储的数据信息。

当两个键值不等时，我们认为这不是一个同一个数组下标存储的数据信息。**但反过来，两个数组下标存储的数据信息相同，不代表他们的键是相同的。**



**问题是第三点，如何找到一个散列函数，使得键值不等的时候，散列值一定不相等？实际上，这是几乎不可能的，这种冲突我们叫做<font color='color'>散列冲突</font>**。数组的存储空间有限，会加大 散列冲突的概率。

## 三、散列冲突

#### 解决散列冲突的两类方法

##### 1、开放寻址法

* 如果出现了散列冲突，则重新探测一个空闲位置。如何探测？有个方式叫**线性探测**。

  <img src="https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg" alt="img" style="zoom: 67%;" />

* 黄色空闲，橙色已经存储了数据。即散列算到下标为7，这时候已经有了数据，则依次向后寻找，直到2的位置是空闲，则插入。
* 在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中

<img src="https://static001.geekbang.org/resource/image/91/ff/9126b0d33476777e7371b96e676e90ff.jpg" alt="img" style="zoom: 50%;" />

* 散列表元素的删除有些特殊，如果直接将数据内容置为空，则会导致原来的查找算法失效，因为查找查到空的位置还没找到则认为不在散列表中。因此我们只能给这个删除的元素一个标志**“deleted”**,查找的时候跳过deteled的空间，继续往下探测。

<img src="https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg" alt="img" style="zoom:50%;" />

* 这种线性探测法问题很大，插入的数据越来越多时，发生散列冲突的可能就会变大，空闲位置会越来越少意味着线性探测的时间会越来越久。最坏情况下复杂度O(n)。

---

除了线性探测，开放寻址还有另外两种经典探测法，**二次探测**和**双重散列**。

* **二次探测**

  探测的下标序列就是 hash(key)+0，hash(key)+1^2，hash(key)+2^2。。。

* **双重散列**

  使用一组散列函数，hash1(key)，hash2(key)，hash3(key)。。第一个下标被占用了就使用第二个散列函数，以此类推，直到找到空闲位置。

---

* 但不管使用哪种探测法，只要数组中的空闲位置变小，都会使得散列冲突的概率增大。为了保证散列表的操作效率，要保证散列表的空槽位占有一定比例，**装载因子**的概念用来表示空位的多少。即：**装载因子=填入表中的元素个数/散列表的长度**，通俗的说就是填充度，填充度越大，散列冲突越容易发生，散列表的性能越低。

##### 2、链表法

* 链表法更加常用，而且相比开放寻址法更为简单。每个散列槽会对应一个链表，散列值相同的元素会放到相同槽位对应的链表中。插入的时候只需要哈希出槽位，再插入到对应的链表中即可，复杂度O(1)；查找和删除复杂度和链表的长度k成正比，即O(k)，理论上k=n/m，n是散列中数据的个数，m是槽的个数。

![img](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg)



## 四、总结

* 散列表两个核心问题是**<font color='red'>散列函数设计</font>**和**<font color='red'>散列冲突解决</font>**。散列冲突有两种常用的解决方法，**开放寻址法**和**链表法**。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。



## 五、习题

* 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

* 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

