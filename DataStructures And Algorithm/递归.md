# 递归

### 一、如何理解递归

* 递归是个很难思考的概念。因为我认为它不符合人的思维方式习惯，但是刚好符合计算机的运算方式。
* 当求解一个问题时，需要求前一个条件的问题（子问题），求前一个条件的问题就需要求前前一个条件的问题（子子问题）。。。如此一直  ”递“到最开始我们已知的初始条件的问题，根据这个最开始的已知条件问题答案再层层”归“来一个个求解父问题，直到最后一个问题。
* 例如单链表中如果想要知道某个元素的位置，你需要找到它上一个元素，找上一个元素你需要找到上上一个元素。。。最后你需要找到最开始的元素，之后再往下遍历。这就是一种递归。



### 二、递归需要满足的三个条件

什么问题可以用递归来解决呢？

（1）一个问题可以分为几个子问题的解。

（2）这个问题与分解的子问题除了数据规模不同，求解思路方式完全一样。

（3）存在递归终止条件。没有终止条件就会一直“递”下去，“归”不来。程序最终崩溃。



### 三、如何编写递归代码

* 写出递归代码的关键有两个：<font color='red'>**总结出递归公式，找到终止条件**。</font>

* 假如有n个台阶，每次可以跨1个或者2个台阶，那么走完这些台阶有多少种走法？

  **找递推公式**

  假设n(n>2)个台阶的走法是f(n)个,那么第一步有2种走法，走1个台阶或者走2个台阶。走1个则剩下n-1个台阶，有f(n-1)个走法；走2个则剩下n-2个台阶，有f(n-2)个走法。那么f(n) = f(n-1) + f(n-2)。这就是问题的递推公式了。

  **找终止条件**

  当只有1个台阶的时候，只有1种走法，不需要递归，即f(1) = 1;2个台阶的时候，按照递推公式f(n) = f(n-1) + f(n-2),则f(2) = f(1) + f(0)。 但是f(0)是多少呢？我们知道2个台阶肯定只有2种走法，第一步跨1个台阶，或者第一步跨2个台阶。即f(2) = 2。因此我们规定(2) = 2。所以我们就得到了两个终止条件。

  所以代码：

  ```java
  int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
  }
  ```

* <font color='red'>因此写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</font>

* 思考方式是，当问题A能分解成多个子问题BCD时，不用想BCD子问题怎么解决，而是思考在BCD已经解决的基础上，怎么解决A，思考两层的关系即可。因为每一层的解决方案都是一样的。之后找出终止条件。



### 四、编写递归代码的警惕

#### 	警惕堆栈溢出

​	如果递归求解的数据规模很大，调用很深，就一直会有新的变量压入栈，最后就有堆栈溢出的风险。

```java
public class Recurse {
	public Recurse() {
		new Recurse();
	}
	public static void main(String[] args) {
		new Recurse();
	}
}
```

* 例如上面代码，创建对象默认会执行对象的构造函数，而构造函数中又创建对象。。就形成了无限递归而没有终止条件。最后就会栈溢出。

* 如何避免这种情况，可以通过设置递归调用的最大深度来解决。当递归调用到一定次数后，不再调用而是直接抛出异常。不过这也不能从根本上解决问题，因为事先很难计算剩余的栈空间大小。所以写递归代码是比较危险的，除非我们明确知道这种递归代码的调用深度不会很深。

#### 警惕重复计算

* 上台阶的问题，会出现很多重复的代码计算。

<img src="https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg" alt="img" style="zoom:60%;" />

* 很明显求解f(6)的时候，f(4),f(3)等都被求解了多次。为了避免重复计算，可以通过散列表来保存求解过的值，当调用f(k)的时候先判断是否已经求解过了，如果求解过了则直接返回。

```java

public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList可以理解成一个Map，key是n，value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSolvedList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}
```

这种方式虽然避免了重复计算，但是开辟了额外的存储空间。不过相对于递归造成的空间使用，我认为这种额外的空间是值得的。（递归造成的空间复杂度总是会很大）



### 五、如何将递归代码改为非递归代码

* 基本上递归代码都可以写成迭代循环的方式。但实际上这种迭代循环的方式是一种“手动递归”。并没有避免递归可能出现的问题，并且还增加了实现的复杂度。递归的好处就是写起来很简洁。但是空间复杂度高，可能堆栈溢出等。
* 如果把上台阶的问题改成迭代循环，则

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```

