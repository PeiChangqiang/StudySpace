## 链表（上）链表介绍

#### 物理存储结构

通过“指针“将一组**零散的内存块**串联起来使用。（数组则需要连续的内存空间）



#### 常见的链表逻辑结构

##### 单链表

<img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img" style="zoom:50%;" />

* 每个节点包括两部分：数据和下一个节点的地址（地址也算是数据，所以我喜欢理解为每个节点存储两类数据）。

* 记录下一个节点地址的指针叫做**后继指针**next。

* 单链表的尾结点存储的是**null**。因此我们在单链表中看到节点的指针数据存储的是null，说明这是一个尾结点。

##### 单链表的操作复杂度

（1）插入和删除

<img src="https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg" alt="img" style="zoom:50%;" />

* 因为只需要改变相邻节点的地址数据（即指针）即可，所以时间复杂度是O(1)。

（2）随机访问

* 这就是链表弊端的地方，随机访问需要根据节点指针一个一个去遍历，所以复杂度O(n)。

##### 双链表

![img](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)

双向链表比单链表每个节点多存储了一个指针，指向上一个节点。

实际删除链表的一个节点，需要知道删除节点的上一个节点，这时候单链表仍然需要遍历，复杂度为O(n)，而双向链表则无需遍历，复杂度为O(1)。这里**用空间换取了时间**。

##### 循环链表

它和单链表的唯一区别就是尾节点指向的不是null，而是头节点。

![img](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)





#### 数组链表性能对比

1.插入、删除和随机访问的时间复杂度

* 数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。
* 链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。

2.数组缺点
* 1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
* 2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。

3.链表缺点
* 1）内存空间消耗更大，因为需要额外的空间存储指针信息。

* 2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。

4.如何选择？

* 数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。
如果代码对内存的使用非常苛刻，那数组就更适合。