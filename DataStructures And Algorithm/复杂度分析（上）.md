# 复杂度分析（上）

#### 复杂度分析分为2种：

时间复杂度，空间复杂度。



#### 为什么需要复杂度分析？





## 时间复杂度分析

#### 时间复杂度分析的重要规律

所有代码的执行时间 T(n) 与<font color='red'>**每行代码的执行次数** </font>n 成正比

**T(n) = O(f(n))**

公式表示的是，代码执行时间**随数据规模增长的变化<font color='red'>趋势</font>**





#### 时间复杂度分析的实用方法

* **只关注循环执行次数最多的一段代码**
* **加法法则：总复杂度等于量级最大的那段代码的复杂度**
* **乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**





#### 几种常见的时间复杂度分析

![img](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)



###### 上图可粗略的分为2类

* 多项式量级

  1. **O(1)**	表示常量级时间复杂度

  2. **O(logn),O(nlogn)**    对数阶时间复杂度
  
     ```java
      i=1;
      while (i <= n)  {
        i = i * 2;
      }
     ```
  
     **代码的执行次数取决于i什么时候大于n。而i什么时候大于n取决于i的增长速度。**
  
     i的取值是一个等比数列：2,4,8,2^4,2^5...2^k，也就是说2^k > n时，代码就不执行了，此时代码执行了k次。k = log2n。因此这段代码的时间复杂度是O(log2n)。
  
  3. **O(m+n)、O(m*n)**
  
     ```java
     
     int cal(int m, int n) {
       int sum_1 = 0;
       int i = 1;
       for (; i < m; ++i) {
         sum_1 = sum_1 + i;
       }
     
       int sum_2 = 0;
       int j = 1;
       for (; j < n; ++j) {
         sum_2 = sum_2 + j;
       }
     
       return sum_1 + sum_2;
     }
     ```
  
     这段代码复杂度由两个数据规模m,n决定，但是事先不能确定哪个数据规模大，因此不能省略其中一个，所以该复杂度为O(m+n)。
  
     
  
* 非多项式量级

  O(2^n) 和 O(n!)

  非多项式量级的算法问题叫作 NP,当n急剧增加时，它的解决时间会无限增长，所以十分低效。





## 空间复杂度分析

**表示的是算法的存储空间与数据规模之间的增长关系**

常见的空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。









## 总结

<font color='green'>越高阶的复杂度的算法，执行效率越低</font>

![img](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg)