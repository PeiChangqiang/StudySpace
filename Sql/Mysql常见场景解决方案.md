# Mysql常见场景解决方案

### 一、带过滤条件的计数

##### 	1.问题描述

* 

### 二、实现Oracle的rank排名效果

##### 	1.问题描述

* 由于Mysql没有rank函数，常常会给查询带来不便。这种场景是要根据相同值的某个列字段给它增加标志位的排名。例如原始表的数据如下

|  id  | 姓名 | 分数 |
| :--: | :--: | :--: |
|  1   |  aa  |  68  |
|  2   |  bb  |  72  |
|  3   |  cc  |  93  |
|  4   |  dd  |  72  |
|  5   |  ee  |  74  |
|  6   |  ff  |  89  |
|  7   |  gg  |  93  |

* 根据原始表的数据最终想要实现的效果是

|  id  | 姓名 | 分数 | 排名 |
| :--: | :--: | :--: | :--: |
|  3   |  cc  |  93  |  1   |
|  7   |  gg  |  93  |  1   |
|  6   |  ff  |  89  |  2   |
|  5   |  ee  |  74  |  3   |
|  2   |  bb  |  72  |  4   |
|  4   |  dd  |  72  |  4   |
|  1   |  aa  |  68  |  5   |

* 即增加排名列，相同的分数排名一样。值从1累加，碰到分数列的值和之前一样，排名列的值则不累加，保持一致。

##### 2.解决方案

首先按照分数倒序排列就可以获得前三列，增加一列需要手动写一个伪列（select @i := 0） as t。

即==select stu.* ,@i:=@+1 from ((select id,name,score from student) stu,(select @i:=0 ) as t)==

该方式会增加一列依次从1,2,3往下排列。但是同分数的应该处于同一个排名，因此需要增加一个变量，来记录当前的分数，来判断是否和之前一样。

==select stu.*,case when==

==@j = stu.score then @i,==

==when @j:= stu.score then @i:=@i+1==

==end as rank from ((select id,name,score from student)stu,(select @i:=0,@j=null) as t);==